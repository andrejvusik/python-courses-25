# python-courses-25

Homeworks for the course "Python".

**HW 7 (HTTP requests)**
Темы: HTTP, requests, скрейпинг.
Задача 1.
Написать скрипт на Python, который считывает список названий стран из
текстового файла, получает информацию о каждой стране с англоязычной
Википедии и сохраняет результат в CSV-файл.

Входной файл

- Вам будет предоставлен файл countries.txt.
- Каждая строка файла - название одной страны на английском.
  Задание.
  Для каждой страны из списка:
- Открыть её страницу на английской Википедии.
- Извлечь следующую информацию:
  -- Столица
  -- Общая площадь (в квадратных километрах)
  -- Население (последнее доступное значение)
  -- Сохранить эти данные в CSV-файл с названием countries_data.csv.

Выходные данные.
CSV файл должен иметь следующую структуру:
country,city,area,population
France,Paris,551695,67081000
Brazil,Brasília,8515767,214000000
Japan,Tokyo,377975,125800000

Дополнительные требования:

- Используйте библиотеки requests, BeautifulSoup, csv
- Обрабатывайте исключения (например, при отсутствии данных или сетевых ошибках).
- Приводите данные к единому виду (например, удаляйте запятые из чисел).
- Добавьте паузу между запросами (например, time.sleep(1)), чтобы не
  перегружать сервер Википедии.

Задача 2
Реализуйте возможность задавать имена входного и выходного файлов через
аргументы командной строки.

Задача 3
Кэшируйте загруженные страницы, чтобы избежать повторных запросов.

**HW 6 (linters)**
Темы: линтеры, CI/CD.
Задача 1.
Настройте GitHub Actions в вашем репозитории с домашними работами так,
чтобы в ваших pull requests автоматически запускались следующие проверки
кода:

1. black.
2. isort.
3. flake8.
4. mypy.

Если хоть одна из этих проверок не пройдет успешно, мердж pull request
должен быть запрещен.

Дополнительные материалы:

1. https://docs.github.com/ru/actions/quickstart - гайд по GitHub Actions.
2. https://sourcery.ai/blog/github-actions - гайд по GitHub Actions + Python
3. https://habr.com/ru/articles/476368/ - еще один гайд по настройке GitHub
   Actions для Python. Нужно сделать то же самое, только запускать не
   тесты, а линтеры.

**HW 5 (data structures)**
Темы: ООП, протокол итерации, стек, очередь, список.

Задача 1.
Реализуйте структуру данных стек (Stack). Стек - это структура данных,
коллекция, работающая по принципу "последним пришел - первым вышел"
(LIFO - last in, first out). Это означает, что последний добавленный элемент
будет извлечен из первым.
Детали:

1. Определите класс Node с атрибутами data и next.
2. Определите класс Stack c атрибутами _top_node и _size
3. Stack использует Node для хранения своих элементов.
4. Один элемент стека - один объект класса Node.
5. Объекты класса Node связаны друг с другом через атрибут next.
6. Реализуйте следующие методы в классе Stack:

- __init__() для инициализации стека.
- push(item) для добавления элемента в верхнюю часть стека.
- pop() для удаления и возврата верхнего элемента стека.
- peek() для возврата верхнего элемента без его удаления.
- is_empty() для проверки, пуст ли стек.
- size() для возврата количества элементов в стеке.
- display() для вывода стека от начала до конца

Задача 2.
Реализуйте структуру данных очередь (Queue). Очередь - это структура
данных, коллекция, работающая по принципу "первый пришел - первым вышел"
(FIFO - first in, first out). Это означает, что первый добавленный элемент будет
извлечен первым.
Детали:

1. Определите класс Node с атрибутами data и next.
2. Определите класс Queue, с атрибутами _first_node, _last_node, _size.
3. Queue использует Node для хранения своих элементов.
4. Один элемент очереди - один объект класса Node.
5. Объекты класса Node связаны друг с другом через атрибут next.
6. Реализуйте следующие методы в классе Queue:

- __init__() для инициализации очереди.
- enqueue(item) для добавления элемента в конец очереди.
- dequeue() для удаления и возврата элемента из начала очереди.
- front() для возврата элемента из начала очереди без его удаления.
- is_empty() для проверки, пуста ли очередь.
- size() для возврата количества элементов в очереди.
- display() для вывода очереди от начала до конца

Задача 3.
Реализуйте структуру данных двусвязный список (LinkedList). Двусвязный
список - это структура данных, коллекция, состоящая из последовательности
узлов, где каждый узел содержит ссылку на следующий узел (или None), ссылку
на предыдущий узел (или None), данные.
Детали:

1. Определите класс Node с атрибутами data, next и prev.
2. Определите класс LinkedList, с атрибутами _head_node, _tail_node, _size.
3. LinkedList использует Node для хранения своих элементов.
4. Один элемент списка - один объект класса Node.
5. Объекты класса Node связаны друг с другом через атрибуты next и prev.
6. Реализуйте следующие методы в классе LinkedList:

- __init__() для инициализации списка.
- append(item) для добавления элемента в конец списка.
- prepend(item) для добавления элемента в начало списка.
- insert(item, i) для добавления элемента на позицию i.
- delete(item) для удаления первого вхождения указанного элемента.
- find(item) для возврата узла, содержащего элемент, или None,
  если элемент не найден.
- display(reverse=False) для вывода списка от начала до конца,
  если reverse=False, или от конца до начала, если True.
- __getitem__(i) для получения элемента списка на позиции i.
  https://docs.python.org/3/reference/datamodel.html#object.__getitem__

Задача 4.
Реализуйте прокол итерации для коллекций из предыдущих задач, чтобы
можно было итерироваться по структурам данных в цикле for:

1. Методы __iter__ у коллекций для получения объекта-итератора
2. Сам объект-итератор StackIterator, QueueIterator, LinkedListIterator.
3. Методы __iter__, __next__ у объектов-итераторов для итерации по коллекции.

Дополнительные условия и требования к решениям:

1. Поместите каждую структуру данных в свой файл: stack.py, queue.py, linked_list.py

**HW 4. OOP**
Темы: ООП, функции, работа с файлами.

Задача 1.
Создайте классы, для описания банковской системы: банк, банковский счет,
клиент. Каждый счет должен быть закреплен за клиентом, и иметь свою валюту.
Клиент может иметь несколько счетов, но только по одному для каждой
валюты. Для каждой сущности добавьте уместные поля (на ваш выбор).
Реализуйте следующие методы:

1. Открыть счет для клиента.
2. Закрыть счет клиента.
3. Пополнить банковский счет.
4. Снять сумму со счета.
5. Перевести деньги между счетами.
   Добавьте исключения там, где это уместно (например, при попытке снять со
   счета больше, чем текущий баланс).

Задача 2.
Реализуйте интерфейс в терминале для задачи 1. Используйте цикл while True,
на каждой итерации показывая пользователю меню с возможными действиями
и предлагая пользователю выбрать одно из них через input().
Интерфейс должен запрашивать у пользователя его ID, а потом предоставлять
ему возможность для выполнения описанных банковских операций. Добавьте
проверки на то, что только владелец счета может выполнять операции над ним.

Задача 3.
Добавьте возможность сделать выписку по всем счетам пользователя:
сохранение в файл информации о счетах, их текущем балансе, и суммарном
балансе.

Задача 4*.
Реализуйте поддержку истории операций с банковским аккаунтом. Добавьте
возможность просмотреть ее в терминале.

Задача 5*.
Сохраняйте состояние между запусками программы - реализуйте
сериализацию и десериализацию в файл(ы).

Пояснения:

1. Пользователь может вводить неправильные данные. Везде, где это
   необходимо, добавляйте проверки.
2. Поместите все задачи в один файл: bank.py
3. Поскольку все ДЗ - это одна программа, нацеленная на взаимодействие с
   пользователем, интерфейс должен быть понятным.

**HW 3. Functions**

Темы: функции, декораторы, работа с файлами.

Задача 1.
Напишите функцию, которая принимает список и делает его “плоским”.
Используйте рекурсию. Функция должна модифицировать переданный список,
а не создавать новый.
Пример:
-- list_a = [1, 2, 3, [4], 5, [6, [7, [], 8, [9]]]]
-- flatten_list(list_a)
-- print(list_a)
[1, 2, 3, 4, 5, 6, 7, 8, 9]

Задача 2.
Напишите функцию, которая производит слияние двух словарей. Используйте
рекурсию. В обоих словарях может быть любой уровень вложенности. Вложены
могут быть другие коллекции: словари, списки, множества, кортежи.
Пример:
-- dict_a = {“a”: 1, “b”: {“c”: 1, “f”: 4}}
-- dict_b = {“d”: 1, “b”: {“c”: 2, “e”: 3}}
-- merge_dicts(dict_a, dict_b)
-- print(dict_a)
{“a”: 1, “b”: {“c”: 2, “e”: 3, “f”: 4}, “d”: 1}

Задача 3.
Напишите декоратор log_calls, который записывает в файл время вызова, имя и
аргументы вызванной функции. Один вызов функции - одна строка в файле.
Декоратор должен принимать имя файла для записи в качестве параметра.

Задача 4.
Пользователь вводит матрицу (список списков). Напишите функцию, которая
транспонирует матрицу, не изменяя входную матрицу. Транспонирование
матрицы - операция над матрицей, когда ее строки становятся столбцами с
теми же номерами.

Задача 5.
Напишите декоратор cache, который кэширует результат вызова функции
(сохраняет в словаре). Когда функция вызывается снова с теми же
аргументами, декоратор должен возвращать результат из кэша, вместо того,
чтобы вызывать декорированную функцию.

Задача 6.
Напишите функцию unique_elements, которая принимает вложенный список и
возвращает уникальные элементы.
Пример:
-- list_a = [1, 2, 3, [4, 3, 1], 5, [6, [7, [10], 8, [9, 2 ,3]]]]
-- unique_elements(list_a)
[1, 2, 3, 4, 5, 6, 7, 10, 8, 9]

Задача 7.
Реализуйте функцию merge_sorted_list, которая принимает два
отсортированных списка, и возвращает новый отсортированный список,
содержащий элементы из обоих списков.

Задача 8*.
Реализуйте функцию merge_sort, которая получает несортированный список, и
сортирует его с помощью алгоритма “сортировка слиянием”.

Дополнительные условия и требования к решениям:

1. Запрещается использовать встроенные функции, которые решают
   задачу. Например, если задача “отсортировать список”, то запрещается
   использовать функции sort или sorted.
2. Везде, где есть ввод пользователя, предполагаем, что будут вводится
   корректные данные.
3. Форматирование строк приветствуется.
4. Вывод результатов и промежуточной информации на экран должен
   содержать пояснения, что именно выведено (если необходимо).
5. Каждая задача должна быть помещена в отдельный файл с названием
   task_1.py, task_2.py в директории hw3 и т.д.

**HOMEWORK 2. Built-in Types**

Темы: базовые типы (tuple, list, set, dict), циклы (for, while).

Задача 1. Посчитать слова
Во входной строке записан текст (вводится пользователем). Словом считается
последовательность символов (кроме пробела), идущих подряд. Слова
разделены одним или большим числом пробелов или символами конца строки.
Посчитайте:

1. Сколько раз каждое слово встречается в тексте и стройте словарь
   {слово: количество}.
2. Количество уникальных слов.
   Слова Apple и apple считаются одинаковыми.

Задача 2. Анализ списка чисел
Пользователь вводит список чисел. Числа вводятся через пробел, могут быть
как целые, так и с плавающей точкой. Выведите на экран:

1. Уникальные числа.
2. Повторяющиеся числа.
3. Четные и нечетные чисел.
4. Отрицательные чисел.
5. Числа с плавающей точкой.
6. Сумму всех чисел, кратных 5.
7. Самое большое число.
8. Самое маленькое число.

Задача 3. Второе по величине число
Пользователь вводит список чисел. Найдите второе по величине число.

Задача 4. Сравнение списков чисел
Пользователь вводит 2 набора чисел. Выведите на экран:

1. Числа, которые присутствуют в обоих наборах одновременно.
2. Числа из первого набора, которые отсутствуют во втором, и наоборот.
3. Числа из обоих наборов, за исключением чисел, найденных в пункте 1.

Задача 5. Анаграммы
Пользователь вводит 2 слова. Напишите программу, которая проверяет,
являются ли они анаграммами (первое слово может быть сформировано путем
перестановки букв во втором слове).
Пример:

- “listen”
- “silent”
  True

Задача 6. Удаление дубликатов без set()
Пользователь вводит список (любой). Удалите все дубликаты без использования set().

Задача 7. Сжатие строки
Пользователь вводит строку. Напишите программу, которая сжимает строку
следующим образом: если символ X повторяется N раз, то итоговая строка
должна содержать XN.
Пример:

- “aaaabbbccaff”
  a4b3c2a1f2

Задача 8. Угадай число
Программа случайно загадывает число от 1 до 100.

- Пользователь вводит догадки.
- Программа подсказывает "Больше" или "Меньше".
- Игра продолжается, пока пользователь не угадает.

*Задача 9. Шифр Цезаря
Пользователь вводит строку и число N (может быть как положительным, так и
отрицательным). Напишите программу, которая шифрует строку с помощью
шифра Цезаря.
Шифр Цезаря - это подстановочный шифр, где каждая буква в исходном тексте
сдвигается вверх или вниз по алфавиту на N позиций.
Пример:
Enter N:

- 3
  Enter text:
- hello
  Result: khoor
  Пояснение:
  В слове hello каждая буква сдвигается по алфавиту на 3 позиции. Таким
  образом h становится k (алфавит a b c d e f g h i j k l m n o p q r s t u v w x y z), e
  становится h, l становится o, o становится r.

*Задача 10. Самая длинная подстрока
Найдите самую длинную подстроку без дубликатов ("abcabcbb" → "abc").

Пояснения

1. Каждая задача должна быть помещена в отдельный файл с названием
   task_1.py, task_2.py, и т.д.
2. Для ввода используйте input(), для вывода - print().
3. Вывод результатов и промежуточной информации на экран должен
   содержать пояснения, чтобы было понятно, что именно выводится на
   экран.

**HOMEWORK 1**

Задача 1. Форматирование ФИО
Введите фамилию, имя и отчество. Приведите их к формату Фамилия И.О.
(первая буква имени и отчества с точкой).

Задача 2. Удаление гласных
Введите строку и удалите из нее все гласные (a, e, i, o, u), затем выведите
результат.

Задача 3. Упрощенный шифр Цезаря
Введите маленькую латинскую букву (a–z) и число n. Выведите букву,
сдвинутую в алфавите на n позиций (с учетом зацикливания, т.е. буква z при
n=1 становится a, при n=2 - b, и т.д.)

Задача 4. Проверка пароля
Введите пароль, проверьте, и выведите на экран:

- Если меньше 16 символов → "Слишком короткий"
- Если содержит только буквы или только цифры → "Слабый пароль"
- Иначе → "Надёжный пароль".

Задача 5. Размен денег
Введите сумму в рублях (целое число). Определите, сколько купюр по 100, 50,
10, 5 и 1 рублю потребуется для ее размена.

Задача 6. Магическое число
Введите число и вычислите сумму его цифр. Если число делится на 7 без
остатка, выведите "Магическое число!", иначе просто сумму цифр.

Задача 7. Формат времени
Введите количество секунд и переведите их в минуты и секунды, например, 75
→ 1 минута 15 секунд.

Задача 8. Палиндром
Введите строку и определите, является ли она палиндромом (читается
одинаково слева направо и справа налево).

Задача 9. Сравнение дробных чисел
Введите два числа с плавающей точкой. Выведите True, если их разница по
модулю меньше 0.001, иначе False.

Задача 10. Определение времени по углу
Введите угол (0–360), на который повернута минутная стрелка часов.
Определите, сколько сейчас минут.

Задача 11. Проверка IP адреса
Введите строку. Проверьте, является ли она корректным IP-адресом (формат
должен быть XXX.XXX.XXX.XXX, где XXX - число от 0 до 255).

*Задача 12. Система счисления
Введите число в десятичной системе. Преобразуйте его в двоичную, а затем
снова в десятичную, без использования встроенных функций bin() и int().

*Задача 13. Римские числа
Введите число (1-100). Преобразуйте его в римскую систему (58 → LVIII).

*Задача 14. Римская арифметика
Введите два числа в римской системе (XIV, XXVIII). Вычислите их сумму и
разность, вернув римский результат.

Пояснения

1. Каждая задача должна быть помещена в отдельный файл с названием
   task_1.py, task_2.py, и т.д.
2. Для ввода используйте input(), для вывода - print().
3. Вывод результатов и промежуточной информации на экран должен
   содержать пояснения, чтобы было понятно, что именно выводится на
   экран.